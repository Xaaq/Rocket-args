{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rocket-args Make your arg parsing even more declarative! Source code : https://github.com/Xaaq/Rocket-args Documentation : https://xaaq.github.io/Rocket-args Overview So you wanted a tool that handles parsing arguments? You've come to right place! Key features: fully declarative, less boilerplate code required, type hints, IDE auto-completion - no more strange Namespace objects. Installation You will need Python 3.6+ In order to install it: pip install rocket-args Examples Simple CLI args Create main.py with following content: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args ) Call it with arguments: $ python main.py --my-int 1234 --my-float 12 .34 --my-string abcd MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd ) Auto-generated help $ python main.py --help usage: main.py [ -h ] [ --my-int MY_INT ] [ --my-float MY_FLOAT ] [ --my-str MY_STR ] optional arguments: -h, --help show this help message and exit --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR","title":"Home"},{"location":"#rocket-args","text":"Make your arg parsing even more declarative! Source code : https://github.com/Xaaq/Rocket-args Documentation : https://xaaq.github.io/Rocket-args","title":"Rocket-args"},{"location":"#overview","text":"So you wanted a tool that handles parsing arguments? You've come to right place! Key features: fully declarative, less boilerplate code required, type hints, IDE auto-completion - no more strange Namespace objects.","title":"Overview"},{"location":"#installation","text":"You will need Python 3.6+ In order to install it: pip install rocket-args","title":"Installation"},{"location":"#examples","text":"","title":"Examples"},{"location":"#simple-cli-args","text":"Create main.py with following content: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args ) Call it with arguments: $ python main.py --my-int 1234 --my-float 12 .34 --my-string abcd MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd )","title":"Simple CLI args"},{"location":"#auto-generated-help","text":"$ python main.py --help usage: main.py [ -h ] [ --my-int MY_INT ] [ --my-float MY_FLOAT ] [ --my-str MY_STR ] optional arguments: -h, --help show this help message and exit --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR","title":"Auto-generated help"},{"location":"contributing/","text":"You want to contribute? Great! Below you will find instructions how to setup environment, launch tests, build docs etc. Setup environment Before you start install [pyenv]https://github.com/pyenv/pyenv) if you haven't yet - it is tool for managing python versions. Clone repo. Install appropriate python versions supported by this repository by pyenv : $ pyenv install 3.8.0 && pyenv install 3.7.5 && pyenv install 3.6.9 Make pyenv automatically use those versions - it will use first version and fallback to next ones when there is need (what will be used when launching tox ): $ pyenv local 3.8.0 3.7.5 3.6.9 Install poetry - tool for dependency managing, building and deploying packages: $ pip install poetry Make poetry install all needed packages (from pyproject.toml ) and create virtualenv for you: $ poetry install Go inside virtualenv created by poetry : $ poetry shell Note If you will exit shell and open it afresh make sure to execute this command again - otherwise installed python packages probably won't be available. poetry have already installed pre-commit for you - we use it to run various formatters automatically on every commit. To turn on (install) pre-commit in this repository type: $ pre-commit install Running tests You can run tests either against you actual python version - faster version (good for fast checking if our changes didn't break anything): $ pytest tests or run them against all supported python versions using tox - slower version (good for final check if everything we've done works): $ tox Building and running docs To build and live-preview docs use following mkdocs command: $ mkdocs serve and then paste link outputted by this command to web browser.","title":"Contributing"},{"location":"contributing/#setup-environment","text":"Before you start install [pyenv]https://github.com/pyenv/pyenv) if you haven't yet - it is tool for managing python versions. Clone repo. Install appropriate python versions supported by this repository by pyenv : $ pyenv install 3.8.0 && pyenv install 3.7.5 && pyenv install 3.6.9 Make pyenv automatically use those versions - it will use first version and fallback to next ones when there is need (what will be used when launching tox ): $ pyenv local 3.8.0 3.7.5 3.6.9 Install poetry - tool for dependency managing, building and deploying packages: $ pip install poetry Make poetry install all needed packages (from pyproject.toml ) and create virtualenv for you: $ poetry install Go inside virtualenv created by poetry : $ poetry shell Note If you will exit shell and open it afresh make sure to execute this command again - otherwise installed python packages probably won't be available. poetry have already installed pre-commit for you - we use it to run various formatters automatically on every commit. To turn on (install) pre-commit in this repository type: $ pre-commit install","title":"Setup environment"},{"location":"contributing/#running-tests","text":"You can run tests either against you actual python version - faster version (good for fast checking if our changes didn't break anything): $ pytest tests or run them against all supported python versions using tox - slower version (good for final check if everything we've done works): $ tox","title":"Running tests"},{"location":"contributing/#building-and-running-docs","text":"To build and live-preview docs use following mkdocs command: $ mkdocs serve and then paste link outputted by this command to web browser.","title":"Building and running docs"},{"location":"tutorial/first_steps/","text":"Basic usage To parse command line arguments in the simplest possible way create class that is inheriting after RocketBase . Then for every CLI argument that you want to add, create class field with appropriate type hint: class MyArgs ( RocketBase ): my_int : int # for CLI argument --my-int my_float : float # for CLI argument --my-float my_str : str # for CLI argument --my-str Note You must provide type hints for class fields so they can be correctly parsed. Then what you need is to call parse_args() method on class (not instance!) to let all CLI parsing magic happen: args = MyArgs . parse_args () Now you can access all fields defined above: print ( args . my_int , args . my_float , args . my_str ) Put all above code into some file - let's say main.py : from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args . my_int , args . my_float , args . my_str ) And launch it with arguments: $ python main.py --my-int 1234 --my-float 12 .34 --my-str abcd 1234 12 .34 abcd Also, all arguments specified in class are required - when you don't provide any of them you will get following message: $ python main.py usage: scratch.py [ -h ] --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR scratch.py: error: the following arguments are required: --my-int, --my-float, --my-str Pretty-printing CLI arguments To reduce amount of boilerplate code print your arguments instance directly: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args ) Now launch it: $ python main.py --my-int 1234 --my-float 12 .34 --my-str abcd MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd ) Default values You can specify default values for your fields: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int = 123 my_float : float = 12.34 my_str : str = \"abcd\" args = MyArgs . parse_args () print ( args ) Every CLI argument whose class field has default value assigned doesn't have to be provided from command line. So launching above script without CLI arguments will work: $ python main.py MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd ) Of course you can overwrite them by providing arguments from command line: $ python main.py --my-int 5678 --my-float 56 .78 --my-str efgh MyArgs ( my_int = 5678 , my_float = 56 .78, my_str = efgh ) Help When you launch above script with --help parameter you will get help message: $ python main.py --help usage: main.py [ -h ] [ --my-int MY_INT ] [ --my-float MY_FLOAT ] [ --my-str MY_STR ] optional arguments: -h, --help show this help message and exit --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR Generated CLI argument names For every class field there will be generated CLI argument following these steps: All underscores will be changed to dashes. Two leading dashes will be added. For example: field arg -> CLI argument --arg field long_arg_name -> CLI argument --long-arg-name","title":"First steps"},{"location":"tutorial/first_steps/#basic-usage","text":"To parse command line arguments in the simplest possible way create class that is inheriting after RocketBase . Then for every CLI argument that you want to add, create class field with appropriate type hint: class MyArgs ( RocketBase ): my_int : int # for CLI argument --my-int my_float : float # for CLI argument --my-float my_str : str # for CLI argument --my-str Note You must provide type hints for class fields so they can be correctly parsed. Then what you need is to call parse_args() method on class (not instance!) to let all CLI parsing magic happen: args = MyArgs . parse_args () Now you can access all fields defined above: print ( args . my_int , args . my_float , args . my_str ) Put all above code into some file - let's say main.py : from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args . my_int , args . my_float , args . my_str ) And launch it with arguments: $ python main.py --my-int 1234 --my-float 12 .34 --my-str abcd 1234 12 .34 abcd Also, all arguments specified in class are required - when you don't provide any of them you will get following message: $ python main.py usage: scratch.py [ -h ] --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR scratch.py: error: the following arguments are required: --my-int, --my-float, --my-str","title":"Basic usage"},{"location":"tutorial/first_steps/#pretty-printing-cli-arguments","text":"To reduce amount of boilerplate code print your arguments instance directly: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int my_float : float my_str : str args = MyArgs . parse_args () print ( args ) Now launch it: $ python main.py --my-int 1234 --my-float 12 .34 --my-str abcd MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd )","title":"Pretty-printing CLI arguments"},{"location":"tutorial/first_steps/#default-values","text":"You can specify default values for your fields: from rocket_args import RocketBase class MyArgs ( RocketBase ): my_int : int = 123 my_float : float = 12.34 my_str : str = \"abcd\" args = MyArgs . parse_args () print ( args ) Every CLI argument whose class field has default value assigned doesn't have to be provided from command line. So launching above script without CLI arguments will work: $ python main.py MyArgs ( my_int = 1234 , my_float = 12 .34, my_str = abcd ) Of course you can overwrite them by providing arguments from command line: $ python main.py --my-int 5678 --my-float 56 .78 --my-str efgh MyArgs ( my_int = 5678 , my_float = 56 .78, my_str = efgh )","title":"Default values"},{"location":"tutorial/first_steps/#help","text":"When you launch above script with --help parameter you will get help message: $ python main.py --help usage: main.py [ -h ] [ --my-int MY_INT ] [ --my-float MY_FLOAT ] [ --my-str MY_STR ] optional arguments: -h, --help show this help message and exit --my-int MY_INT --my-float MY_FLOAT --my-str MY_STR","title":"Help"},{"location":"tutorial/first_steps/#generated-cli-argument-names","text":"For every class field there will be generated CLI argument following these steps: All underscores will be changed to dashes. Two leading dashes will be added. For example: field arg -> CLI argument --arg field long_arg_name -> CLI argument --long-arg-name","title":"Generated CLI argument names"}]}